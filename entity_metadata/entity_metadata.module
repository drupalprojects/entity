<?php
// $Id$

/**
 * @file
 * Module file for the entity metadata module.
 */

module_load_include('inc', 'entity_metadata', 'modules/callbacks');

/**
 * Returns a property wrapper for the given data.
 *
 * If an entity is wrapped, the wrapper can be used to retrieve further wrappers
 * for the entitity properties. For that the wrapper support chaining, e.g. you
 * can use a node wrapper to get the node authors mail address:
 *
 * @code
 *   echo $wrappedNode->author->mail->value();
 * @endcode
 *
 * @param $type
 *   The type of the passed data.
 * @param $data
 *   The data to wrap. It may be set to NULL, so the wrapper can be used
 *   without any data for getting information about properties.
 * @param $info
 *   Optional. Specify additional information for the passed data:
 *    - langcode: If the data is language specific, its langauge code. Defaults
 *      to NULL, what means language neutral.
 *    - bundle: If an entity is wrapped but not passed, use this key to specify
 *      the bundle to return a wrapper for.
 *    - data info: May be used to use a wrapper with an arbitrary data
 *      structure (type 'struct'). Use this key for specifying metadata about
 *      properties in the same structure as used by hook_entity_property_info().
 * @return EntityMetadataWrapper
 *   Dependend on the passed data the right wrapper is returned.
 */
function entity_metadata_wrapper($type, &$data = NULL, array $info = array()) {
  if (($entity_info = entity_get_info()) && isset($entity_info[$type])) {
    return new EntityDrupalWrapper($type, $data, $info);
  }
  elseif (entity_metadata_list_extract_type($type)) {
    return new EntityListWrapper($type, $data, $info);
  }
  elseif (isset($info['data info'])) {
    return new EntityStructureWrapper($type, $data, $info);
  }
  else {
    return new EntityValueWrapper($type, $data, $info);
  }
}

/**
 * Extracts the contained type for a list type string like list<date>.
 *
 * @return
 *   The contained type or FALSE, if the given type string is no list.
 */
function entity_metadata_list_extract_type($type) {
  if (strpos($type, 'list<') === 0 && $type[strlen($type)-1] == '>') {
    return substr($type, 5, -1);
  }
  return FALSE;
}

/**
 * Get the entity property info array of an entity type.
 *
 * @see hook_entity_property_info()
 * @see hook_entity_property_info_alter()
 *
 * @param $entity_type
 *   The entity type, e.g. node, for which the info shall be returned, or NULL
 *   to return an array with info about all types.
 */
function entity_metadata_get_info($entity_type = NULL) {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static = array();
  isset($drupal_static[__FUNCTION__]) || ($drupal_static[__FUNCTION__] = &drupal_static(__FUNCTION__));
  $info = &$drupal_static[__FUNCTION__];

  if (empty($info)) {
    if ($cache = cache_get('entity_property_info')) {
      $info = $cache->data;
    }
    else {
      $info = module_invoke_all('entity_property_info');
      // Let other modules alter the entity info.
      drupal_alter('entity_property_info', $info);
      cache_set('entity_property_info', $info);
    }
  }
  return empty($entity_type) ? $info : (isset($info[$entity_type]) ? $info[$entity_type] : array());
}

/**
 * Gets an array of info about all properties of a given entity type.
 *
 * @param $entity_type
 *   The entity type.
 */
function entity_metadata_get_properties($entity_type) {
  $info = entity_metadata_get_info($entity_type);
  $info += array('properties' => array());
  // Add all bundle properties.
  foreach ($info['bundles'] as $bundle => $bundle_info) {
    $bundle_info += array('properties' => array());
    $info['properties'] += $bundle_info['properties'];
  }
  return $info['properties'];
}

/**
 * Implements hook_hook_info_alter().
 */
function entity_metadata_hook_info_alter(&$hook_info) {
  $hook_info['entity_property_info'] = array(
    'group' => 'info',
  );
}

/**
 * Gets the property just as it is set in the entity.
 */
function entity_metadata_verbatim_get($entity, array $options, $name) {
  $name = str_replace('-', '_', $name);
  if (is_array($entity) && isset($entity[$name])) {
    return $entity[$name];
  }
  elseif (is_object($entity) && isset($entity->$name)) {
    return $entity->$name;
  }
  return NULL;
}


/**
 * Sets the property to the given value. May be used as 'setter callback'.
 */
function entity_metadata_verbatim_set(&$entity, $name, $value) {
  $name = str_replace('-', '_', $name);
  if (is_array($entity)) {
    $entity[$name] = $value;
  }
  elseif (is_object($entity)) {
    $entity->$name = $value;
  }
}

/**
 * Getter callback for getting an array. Makes sure it's numerically indexed.
 */
function entity_metadata_get_list($entity, array $options, $name) {
  return isset($entity->$name) ? array_values($entity->$name) : array();
}

/**
 * Implements hook_field_info_alter().
 * Defines default property types for core field types.
 */
function entity_metadata_field_info_alter(&$field_info) {
  // Field API lists are key/value pairs but not multiple valued by default.
  $field_info['list']['property_type'] = 'integer';
  $field_info['list_boolean']['property_type'] = 'boolean';
  $field_info['list_number']['property_type'] = 'decimal';
  $field_info['list_text']['property_type'] = 'text';
  $field_info['number_integer']['property_type'] = 'integer';
  $field_info['number_decimal']['property_type'] = 'decimal';
  $field_info['number_float']['property_type'] = 'decimal';
  $field_info['text']['property_type'] = 'text';
  $field_info['text']['property_callbacks'] = array('entity_metadata_field_text_property_callback');
  $field_info['text_long']['property_type'] = 'text';
  $field_info['text_long']['property_callbacks'] = array('entity_metadata_field_text_property_callback');
  $field_info['text_with_summary']['property_type'] = 'text';
  $field_info['text_with_summary']['property_callbacks'] = array('entity_metadata_field_text_property_callback');
  $field_info['taxonomy_term_reference']['property_type'] = 'taxonomy_term';
  $field_info['taxonomy_term_reference']['property_callbacks'] = array('entity_metadata_field_term_reference_callback');
}

/**
 * Implements hook_entity_info().
 */
function entity_metadata_entity_info() {
  $entity_info['comment']['name property'] = 'title';
  $entity_info['node']['name property'] = 'title';

  // Create a entity for dealing with drupal variables as properties.
  $entity_info['system'] = array(
    'label' => t("System information"),
    // Set some properties to empty arrays to prevent field API errors...
    'fieldable' => FALSE,
    'object keys' => array(),
    'bundles' => array(),
  );

  // Set access callbacks.
  $entity_info['node']['access callback'] = 'entity_metadata_node_access';
  $entity_info['user']['access callback'] = 'entity_metadata_user_access';
  $entity_info['comment']['access callback'] = 'entity_metadata_comment_access';
  $entity_info['taxonomy_term']['access callback'] = 'entity_metadata_taxonomy_access';
  $entity_info['taxonomy_vocabulary']['access callback'] = 'entity_metadata_taxonomy_access';

  // CRUD function callbacks.
  $entity_info['node']['creation callback'] = 'entity_metadata_create_node';
  $entity_info['node']['save callback'] = 'node_save';
  $entity_info['node']['deletion callback'] = 'node_delete';
  $entity_info['user']['creation callback'] = 'entity_metadata_create_object';
  $entity_info['user']['save callback'] = 'entity_metadata_user_save';
  // We don't support user deletion as the user cancelling needs batching.
  $entity_info['comment']['creation callback'] = 'entity_metadata_create_comment';
  $entity_info['comment']['save callback'] = 'comment_save';
  $entity_info['comment']['deletion callback'] = 'comment_delete';
  $entity_info['file']['save callback'] = 'file_save';
  $entity_info['file']['deletion callback'] = 'entity_metadata_file_delete';
  $entity_info['taxonomy_term']['creation callback'] = 'entity_metadata_create_object';
  $entity_info['taxonomy_term']['save callback'] = 'taxonomy_term_save';
  $entity_info['taxonomy_term']['deletion callback'] = 'taxonomy_term_delete';
  $entity_info['taxonomy_vocabulary']['creation callback'] = 'entity_metadata_create_object';
  $entity_info['taxonomy_vocabulary']['save callback'] = 'taxonomy_vocabulary_save';
  $entity_info['taxonomy_vocabulary']['deletion callback'] = 'taxonomy_vocabulary_delete';
  return $entity_info;
}

/**
 * Determines whether the given user has access to an entity.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $entity_type
 *   The entity type of the entity to check for.
 * @param $entity
 *   Optionally an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the global user.
 * @return boolean
 *   Whether access is allowed or not. If no information is available, NULL is
 *   returned.
 */
function entity_metadata_entity_access($op, $entity_type, $entity = NULL, $account = NULL) {
  if (($info = entity_get_info()) && isset($info[$entity_type]['access callback'])) {
    return $info[$entity_type]['access callback']($op, $entity_type, $entity, $account);
  }
}

/**
 * Permanently save the given entity.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $entity
 *   The entity to save.
 * @return
 *   FALSE, if there were no information how to save the entity.
 */
function entity_metadata_entity_save($entity_type, &$entity) {
  $info = entity_get_info($entity_type);
  if (isset($info['save callback'])) {
    $info['save callback']($entity);
  }
  elseif (method_exists($entity, 'save')) {
    $entity->save();
  }
  else {
    return FALSE;
  }
}

/**
 * Permanently delete the given entity.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $id
 *   The uniform identifier of the entity to delete.
 * @return
 *   FALSE, if there were no information how to delete the entity.
 */
function entity_metadata_entity_delete($entity_type, $id) {
  $info = entity_get_info($entity_type);
  if (isset($info['deletion callback'])) {
    $info['deletion callback']($id);
  }
  elseif (isset($info['entity class']) && method_exists($info['entity class'], 'delete')) {
    $entities = entity_load($entity_type, array($id));
    reset($entities)->delete();
  }
  else {
    return FALSE;
  }
}

/**
 * Creates a new entity instance of the given type.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $values
 *   An array of values for properties to set for the new entity. At least the
 *   properties marked as 'required' in the property info have to be passed.
 * @return EntityDrupalWrapper
 *   An EntityDrupalWrapper wrapping the newly created entity or FALSE, if
 *   there were no information how to create the entity.
 */
function entity_metadata_entity_create($entity_type, $values = array()) {
  $info = entity_get_info($entity_type);
  if (isset($info['creation callback'])) {
    return $info['creation callback']($values, $entity_type);
  }
  return FALSE;
}

/**
 * Queries for entities having the given property value.
 *
 * @param $entity_type
 *   The type of the entity.
 * @param $property
 *   The name of the property to query for.
 * @param $value
 *   A property value or an array of possible values to query for.
 * @param $limit
 *   Limit the numer of results. Defaults to 30.
 * @return
 *   An array of entity ids or NULL if there is no information how to query for
 *   the given property.
 */
function entity_metadata_entity_query($entity_type, $property, $value, $limit = 30) {
  $properties = entity_metadata_get_properties($entity_type);
  $property = str_replace('_', '-', $property);
  if (isset($properties[$property]['query callback'])) {
    return $properties[$property]['query callback']($entity_type, $property, $value, $limit);
  }
}
